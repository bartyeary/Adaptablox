
<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<meta name="description" content="A.R.C. — Agent Role & Constraint. A runtime governance layer that regulates tone, behavior, and memory across multi-agent AI systems, ensuring transparency, compliance, and coherence at scale."/>
<title>Adaptablox</title>
<style>
:root {
--gap: 24px;
--card-w: 260px;
--card-h: 220px;
--bg-1: #192447;
--bg-2: #101422;
--front-a: #1E2A45;
--front-b: #293A5F;
--back-a: #293A5F;
--back-b: #293A5F;
--accent: #2879ED;
--max-container: calc(3 * var(--card-w) + 2 * var(--gap)); /* optional, cleaner */
}

/* Global page */
body {
  font-family: "Inter", sans-serif;
  background: radial-gradient(circle at 500px 0%, var(--bg-1), var(--bg-2) 1000px);
  color: #7299e2;
  font-weight: 400;
  margin: 0;
  min-height: 100vh;
  padding: 60px 0 60px;   /* ← REMOVE left/right padding */
  overflow-x: hidden;
  box-sizing: border-box;
}

html { background-color: #10182E; }

p {
  line-height: 1.5;
  margin-bottom: 1.2rem;
}

.softbreak {
  display: block;
  height: 0.45rem; /* or whatever spacing you want */
}

/* Full-bleed wrapper */
.page-wrap {
  width: 100%;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Controller Row */
.controls {
position: fixed;
top: 0;
left: 0;
width: 100%;
z-index: 100;
backdrop-filter: blur(8px);
background: rgba(37,50,89,0.5);
display: flex;
justify-content: flex-start;
}

.controls-inner {
  width: 100%;
  max-width: none;
  padding-left: var(--gap);
  padding-right: var(--gap);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  padding: 12px var(--gap);
}

.deck-toggle {
display: flex;
gap: 8px;
background: #141B2E;
border-radius: 10px;
padding: 6px;
}

.deck-toggle button {
background: transparent;
border: none;
color: #fff;
padding: 8px 14px;
border-radius: 6px;
cursor: pointer;
font-weight: 600;
transition: background .18s;
}

.deck-toggle button.active { background: var(--accent); }

.logo {
height: 32px;             /* adjust as needed */
width: auto;
margin-right: 16px;
display: block;
transition: height 0.25s ease, transform 0.25s ease;

}

.controls-inner > .logo {
margin-right: 20px;
}

.section-container {
  width: 100%;
  max-width: 820px;         /* match inner-container */
  margin: 20px auto;
  background: #141B2E;
  border-radius: 12px;
  padding: var(--gap);      /* uniform padding on ALL sides */
  box-shadow: 0 15px 20px rgba(0,0,0,0.15);
}

/* Inner centering container */
.section-container > .inner-container {
  width: 100%;
  max-width: 100%;   /* do NOT use 820px here */
  padding: 0;        /* section handles spacing now */
  margin: 0;         /* no offsets */
}

.section-container.active {
display: block; /* back in flow */
opacity: 1;
transform: translateY(0);
pointer-events: auto;
}




/* ABOUT SECTION */
#about {
font-family: "Inter", sans-serif; /* switched from Courier */
line-height: 1.6;
font-size: 15px;
letter-spacing: 0.1px;
}

#about h1, #about h2, #about h3 {
color: #f0f3fa;
font-weight: 600;
letter-spacing: 0.3px;
text-transform: uppercase;
margin-bottom: 6px;       /* keep spacing below */
padding-top: 10px;           
padding-left: 0;            /* aligns with section padding */
}

#about h1{
font-size: 1.2em;
margin-top: 0;
}
#about h2{
font-size: 1.2em;
margin-top: 0;
}


#about ul {
list-style: none;
padding: 0;

}

#about li {
position: relative;
padding-left: 1.2em;
margin: 1em 0;
}

#about li::before {
content: "•";
position: absolute;
left: 0;
color: #2978ED;
font-weight: bold;
}

#about ul li strong {
  color: #BBD0FE;
}

#about .compare {
background: #1E2A45;
color: #8FB0ED;
padding: 16px 20px;
border-radius: 8px;
margin: 1.2em 0;
line-height: 1.6;
font-size: 14px;
border-left: 4px solid #2978ED; /* the accent stroke */
}

#about .compare strong{
  color: #ffffff;
}


#about .video-embed {
margin: 32px 0;
border-radius: 12px;
overflow: hidden;
background: #101422;
}

#about .video-frame {
position: relative;
padding-top: 56.25%; /* 16:9 aspect ratio */
}

#about .video-frame iframe {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
border: none;
border-radius: 12px;
}

#about .caption {
font-size: 13px;
color: #7e8aa7;
margin-top: 6px;
text-align: center;
}

/* Cards + Flows (unchanged) */
.card-container {
display: grid;
grid-template-columns: repeat(3, var(--card-w));
gap: var(--gap);
justify-content: center;
}
/* Ensure each layer participates in 3D */
.card {
height: var(--card-h);
position: relative;
cursor: pointer;
perspective: 1000px;              /* 3D camera */
}

.inner {
position: absolute;
inset: 0;
border-radius: 6px;
transform-style: preserve-3d;     /* keep children 3D */
transition: transform 0.6s ease;
}

.card.flipped .inner { transform: rotateY(180deg); }

.tilt {
position: absolute;
inset: 0;
border-radius: 6px;
transform-style: preserve-3d;     /* keep faces 3D */
transition: transform 0.25s ease, box-shadow 0.25s ease;
box-shadow: 0 15px 30px rgba(0,0,0,0.32);
}

.card .face {
  --lx: 135deg;      /* gradient light direction X */
  --ly: 135deg;      /* gradient light direction Y */
}

.face {
position: absolute;
inset: 0;
display: flex;
align-items: center;
justify-content: center;
text-align: center;
padding: 12px;
border-radius: 6px;
backface-visibility: hidden;
-webkit-backface-visibility: hidden;   /* Safari */
transform: translateZ(0);               /* avoid z-fighting */
transition: --lx 0.35s ease-out;
}

.front { 
background: linear-gradient(var(--lx, 0deg), var(--front-b), var(--front-a));
transform: rotateY(0deg);
color: #6A8FD4;
}

.back  { 
background: linear-gradient(var(--lx, 0deg), var(--back-a), var(--back-b));
transform: rotateY(180deg);
color: #fff;
}

.card .face.back p {
  font-size: 14px;
  line-height: 1.5;
  color: #bcd1ff;
  transition: color 0.25s ease;
}

/* Optional: belt-and-suspenders for nested text */
.face * { backface-visibility: hidden; -webkit-backface-visibility: hidden; }

/* Text color shift on hover */
.card:hover .face.front h3,
.card:hover .face.back p {
  color: #fff;
  transition: color 0.25s ease;
}

/* FLOW TITLES & DESCRIPTIONS (match About section styling) */
.ascii-section .ascii-title {
font-family: "Inter", sans-serif;
color: #f0f3fa;              /* same as About headers */
font-weight: 600;
text-transform: uppercase;
font-size: 18px;
letter-spacing: 0.3px;
padding-top: 10px; 
margin-bottom: 8px;
}

.ascii-section .ascii-desc {
font-family: "Inter", sans-serif;
font-size: 15px;
line-height: 1.6;
color: #8FB0ED;              /* same as About body */
margin-bottom: 28px;
}
.ascii-pre {
display: block;
font-size: 14px;
line-height: 1.25;
white-space: pre;
overflow-x: auto;
color: #b8d0ff;
margin: 24px auto 0;          /* center within section and add spacing */
text-align: center;           /* centers ASCII art lines */
max-width: 100%;
}

#flowNav { display: none; gap: 8px; }
#flowNav button {
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: transparent;
  border: 2px solid var(--accent);
  color: var(--accent);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.18s ease;
}

#flowNav button svg {
  width: 18px;
  height: 18px;
}

#flowNav button:hover {
  background: var(--accent);
  color: #fff;
}

.left-group {
display: flex;
flex-direction: row;  /* ensures logo + controller sit side by side */
align-items: center;  /* vertical alignment */
gap: 8px;            /* spacing between logo and buttons */
}

.site-footer {
text-align: center;
font-size: 13px;
color: #345287;
margin-top: 60px;
padding-top: 24px;
width: 100%;
}

.site-footer p {
margin: 0;
letter-spacing: 0.3px;
}



/* Limit width of text-heavy sections */
#about.section-container,
#ascii.section-container {
  max-width: 780px !important;   /* perfect for text + breathing room */
  margin-left: auto !important;
  margin-right: auto !important;
}

/* --- 900px breakpoint --- */
@media (max-width: 900px) {
:root {
--card-w: 220px;
--card-h: 200px;
--gap: 20px;
}

.logo {
height: 30px;
}

.card .face.front h3 {
font-size: 15px;
}
.card .face.back p {
font-size: 13px;
line-height: 1.4;
}
}

/* --- 750px breakpoint --- */
@media (max-width: 750px) {
:root {
--card-w: 180px;
--card-h: 160px;
--gap: 16px;
}

.logo {
height: 25px;
}

.card .face.front h3 {
font-size: 14px;
}
.card .face.back p {
font-size: 12px;
line-height: 1.35;
}
}

/* --- 600px breakpoint --- */
@media (max-width: 600px) {
  :root {
  --card-w: 120px;
  --card-h: 100px;
  --gap: 8px;
  }

  #about.section-container,
  #ascii.section-container {
  max-width: 380px !important;   /* perfect for text + breathing room */
  margin-left: auto !important;
  margin-right: auto !important;
  }

  .ascii-pre {
    font-size: 8px;
  }

  .logo {
    display: none !important;
  }

  /* Make control row left-aligned ALWAYS */
.controls-inner {
  width: 100%;
  max-width: none !important;   /* critical fix — removes unwanted centering */
  display: flex;
  align-items: center;
  justify-content: flex-start;
  padding-left: var(--gap);     /* matches section-container left margin */
  padding-right: var(--gap);
  gap: 12px;
}

  /* Prevent inner wrapper from trying to center itself */
  .left-group {
    justify-content: flex-start !important;
    width: auto !important;
  }

  body {
    padding-left: 0 !important;
    padding-right: 0 !important;
  }

  .section-container {
    width: 100% !important;
    border-radius: 0;
    margin: 8px 0 !important;
  }

  /* ===== NEW: Keep prev/next buttons on the right in flows mode ===== */
  #flowNav {
    margin-left: auto !important; /* pushes it to the right edge */
    align-items: center;
  }


  #terms.card-container,
  #faq.card-container {
    grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
    gap: 16px 16px !important;
    padding: 16px 0 16px !important;
    justify-content: center !important;
  }
  #about.section-container,
  #ascii.section-container {
    padding: 14px 14px !important;
  }

  .card .face.front h3 {
  font-size: 12px;
  }
  .card .face.back p {
  font-size: 10px;
  line-height: 1.25;
  }
  }

/* emphasize with your accent color and italic */
em {
  color: #BBD0FE;          
  font-style: italic;
  font-weight: 600;
}
em.noitalic {
  font-style: normal;
  font-weight: 600; /* optional emphasis */
}

/* strong emphasis with brighter color and weight */
strong {
  color: #BBD0FE;          /* a lighter or more luminous accent */
  font-weight: 700;        /* keep it bold but not too heavy */
}

</style>
</head>

<body>
<div class="page-wrap">
<div class="controls">
<div class="controls-inner">
<div class="left-group">
<img src="arc-logo.svg" alt="A.R.C. logo" class="logo">
<div class="deck-toggle">
  <button id="aboutBtn" class="active" aria-label="View About section">About</button>
  <button id="termsBtn" aria-label="View Terms section">Terms</button>
  <button id="faqBtn" aria-label="View FAQs section">FAQs</button>
  <button id="flowsBtn" aria-label="View Flows section">Flows</button>
</div>
</div>
<div id="flowNav">
  <button id="prevFlow" aria-label="Previous diagram">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="15 18 9 12 15 6" />
    </svg>
  </button>
  <button id="nextFlow" aria-label="Next diagram">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="9 18 15 12 9 6" />
    </svg>
  </button>
</div>
</div>
</div>

<!-- Inline About Section -->

<div class="section-container active" id="about">
  <div class="inner-container">
<div>
<h1>Governance for Intelligent Systems</h1>
<p>
Adaptablox is a runtime governance platform for AI systems. It regulates how agents behave at the surface level and how models reason at the internal level.<span class="softbreak"></span>
It brings coherence, safety, and continuity to autonomous AI by combining two complementary layers:
<br><br>

<em class="noitalic">Agent Role & Constraint</em> (A.R.C.) governs <em>the outer loop:</em> agent behavior, tone, memory, delegation, and coordination across agents.<br><br> 
<em class="noitalic">Latent Role & Constraint</em> (L.R.C.) governs <em>the inner loop:</em> internal reasoning dynamics, latent representations, activation patterns, and controlled arbitration within the model.<br><br>

Together, these layers create a behavioral operating foundation that stabilizes how AI systems act and think in real time.
</p>

<h2>Why Adaptablox matters</h2>
<p>
Most AI platforms focus on access control. They decide <em>who</em> can use <em>which</em> data or tool.<span class="softbreak"></span>
Adaptablox focuses on what happens after access is granted. It governs <em>how</em> behavior unfolds and <em>how</em> internal reasoning develops.<br><br>

<em class="noitalic">A.R.C.</em> shapes actions, tone, memory usage, and collaboration across agents.<br><br>
<em class="noitalic">L.R.C.</em> shapes internal cognition by regulating which latent patterns engage, how they interact, and how internal conflicts are resolved.<br><br>

Together, they support governed autonomy without requiring model retraining or static rule sets.
<br>
</p>

<div class="compare">
<strong>Without Adaptablox</strong><br>
AI systems rely on static prompts and brittle safety wrappers that fail once autonomy, memory, or multi-agent workflows appear.
Behavior drifts, memory bleeds across contexts, and internal reasoning becomes difficult to interpret or control.
Outcomes are inconsistent, costly, and hard to audit.
</div>

<div class="compare">
<strong>With Adaptablox</strong><br>
Behavior and internal reasoning adjust immediately to changing context.
Tone, memory, internal activation, and task delegation follow explicit policies and remain transparent.
Agents respond with continuity, and models reason within defined boundaries.
Unnecessary or repetitive reasoning is reduced, keeping systems efficient and cost-effective at scale.
</div>

<h2>Key Differentiators</h2>
<ul>
<li><strong>Dual-loop Runtime Governance</strong><br>
A.R.C. manages behavior at the agent level while L.R.C. governs internal cognitive processes. Together they regulate tone, memory, permissions, internal activation behavior, and both inter-agent and intra-model deliberation.</li>

<li><strong>Constraint-Aware Memory</strong><br>
Adaptablox governs what information agents retain or recall. It enforces retention limits, scoped access, and full provenance across all memory types.</li>

<li><strong>Internal Reasoning Governance</strong><br>
L.R.C. identifies relevant internal mechanisms, applies policy boundaries to their engagement, redirects unsuitable reasoning paths, and resolves conflicts between competing internal interpretations.</li>

<li><strong>Multi-Agent Arbitration</strong><br>
Specialized agents reason together under a shared policy. Their outputs are reconciled so the system presents one coherent, policy-aligned response.</li>

<li><strong>Auditability by Design</strong><br>
Every meaningful behavioral or internal reasoning adjustment is logged with contextual metadata, enabling full traceability.</li>

<li><strong>Model-Agnostic Architecture</strong><br>
Adaptablox works across proprietary, open, and custom models. It does not modify model weights or depend on any specific interpretability approach.</li>

<li><strong>Cost-Aware Governance</strong><br>
The system prevents redundant reasoning and excessive deliberation by enforcing efficient pathways at both the behavioral and internal levels.</li>

<li><strong>Regulatory Readiness</strong><br>
Behavior, memory, and internal reasoning are governed through explicit policies, producing transparent and compliant operation by default.</li>
</ul>

<h2>How Adaptablox interprets prompts</h2>
<p>
Adaptablox treats every input as a source of contextual signals.<span class="softbreak"></span>
A.R.C. infers intent, domain, tone, and risk, then selects the appropriate behavioral mode or delegates to the right agent.<span class="softbreak"></span>
If input falls outside an agent’s scope, A.R.C. adjusts behavior or escalates as needed.<span class="softbreak"></span>
L.R.C. applies similar discipline internally by guiding how reasoning mechanisms engage, interact, or reroute under policy.
</p>

<h2>Configuration and Operation</h2>
<p>
Teams specify high-level intent and policy. Adaptablox generates the surrounding governance structures automatically, including roles, constraints, tone defaults, memory rules, escalation paths, and internal reasoning boundaries.<span class="softbreak"></span>
As agents operate, A.R.C. keeps behavior aligned.<span class="softbreak"></span>
As models reason, L.R.C. keeps internal thinking stable, safe, and auditable.<span class="softbreak"></span>
The result is a unified layer that provides predictable behavior and interpretable reasoning across all agents and models.
</p>

<h2>Vision</h2>
<p>
AI is evolving toward ambient assistance, multi-agent ecosystems, and increasingly interpretable internal structures.<span class="softbreak"></span>
These systems need a stable foundation for both behavior and cognition.<span class="softbreak"></span>
Adaptablox provides that foundation, aligning how intelligence expresses itself with how it reasons.<span class="softbreak"></span>
One system, many agents. One policy, many pathways. A coherent future for autonomous intelligence.
</p>

</div> 
</div>   

<div class="video-embed">
<div class="video-frame">
<iframe
src="https://player.vimeo.com/video/1132838746?title=0&byline=0&portrait=0&badge=0&autopause=0"
frameborder="0"
allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share"
referrerpolicy="strict-origin-when-cross-origin"
title="A.R.C. System Overview"
></iframe>
</div>
<p class="caption">Demo 1 — A.R.C. System Overview: constraint hierarchy, escalation logic, and multi-agent synthesis.</p>
</div>

<div class="video-embed">
<div class="video-frame">
<iframe
src="https://player.vimeo.com/video/1118926409?title=0&byline=0&portrait=0&badge=0&autopause=0"
frameborder="0"
allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share"
referrerpolicy="strict-origin-when-cross-origin"
title="A.R.C. Ambient Assistant"
></iframe>
</div>
<p class="caption">Demo 2 — A.R.C. Ambient Assistant: behavioral tone modulation and real-time orchestration.</p>
</div>

<script src="https://player.vimeo.com/api/player.js"></script>
</div>


<div class="section-container card-container" id="terms">
  <div class="inner-container card-container"></div>
</div>
<div class="section-container card-container" id="faq">
  <div class="inner-container card-container"></div>
</div>
<div class="section-container ascii-section" id="ascii"></div>
</div>

<script>
/* ---------- TERMS & FAQ CARD DATA ---------- */
const termsDeck = [
{
  term: "Behavioral Arc",
  def: "A structured profile that defines an agent’s role, tone, and behavioral boundaries. Each arc governs how reasoning and interaction unfold within policy over time."
},
{
  term: "Task Fingerprint",
  def: "A contextual signature derived from a prompt’s semantics, tone, and intent. It guides routing decisions and helps the system adjust behavior dynamically."
},
{
  term: "Constraint Stack",
  def: "A prioritized set of rule layers that specify what an agent may or may not do within its operational scope."
},
{
  term: "Hybridization",
  def: "The controlled blending of perspectives from multiple agent roles to form a single, policy-aligned response."
},
{
  term: "Escalation",
  def: "A governed process of routing a task to another agent or domain when assurance levels or policy thresholds are exceeded."
},
{
  term: "Tone Profile",
  def: "A dynamic configuration that shapes empathy, urgency, confidence, or authority in an agent’s language according to context and policy."
},
{
  term: "Memory Segmentation",
  def: "Short-term, semantic, episodic, and procedural memory regions managed under constraint and retention policies."
},
{
  term: "Controller Agent",
  def: "A coordinating agent that synthesizes outputs from sub-agents and enforces alignment through constraint-aware reasoning."
},
{
  term: "Constraint Hierarchy",
  def: "A layered rule structure that determines how one agent’s constraints take precedence over another’s when agents collaborate or hybridize."
},
{
  term: "Reflexive Transparency",
  def: "A mechanism by which behavioral adjustments and governance decisions are logged with contextual metadata for auditability."
},
{
  term: "Latent Role Assignment",
  def: "A process that identifies relevant internal mechanisms—such as latent representations or reasoning patterns—and assigns functional roles under policy. This guides internal cognition along governed pathways rather than unconstrained activation."
},
{
  term: "Circuit Guardrail",
  def: "A policy boundary applied within the model’s internal reasoning layer. Guardrails limit unsafe or misaligned internal activity and direct reasoning toward policy-compliant pathways."
},
{
  term: "Sparse-Circuit Arbitration",
  def: "A constraint-guided resolution process where competing internal interpretations or activation patterns are evaluated. The system selects or blends internal reasoning paths that align with policy, analogous to multi-agent arbitration."
},
{
  term: "Activation Rerouting",
  def: "A governed fallback mechanism that redirects internal reasoning to alternative pathways when the original trajectory exceeds allowed boundaries or risk thresholds."
},
{
  term: "Reasoning Limit",
  def: "A constraint on depth, chain length, or pathway expansion in the model’s internal reasoning. These limits prevent runaway reasoning and help maintain policy alignment."
},
{
  term: "Cognitive Trace",
  def: "A lightweight record of which internal components or latent roles contributed to a final output. This provides transparency analogous to A.R.C.’s external audit trail."
},
{
  term: "Latent Escalation",
  def: "The process of transitioning internal reasoning to a safer or more constrained latent role when a pathway approaches a policy boundary or produces uncertain signals."
},
{
  term: "Reasoning Policy",
  def: "A set of internal governance rules that guide how latent mechanisms activate, interact, suppress, or escalate. It maintains alignment with organizational or system-level constraints."
}
];

const faqDeck = [
{
  term: "Does A.R.C. improve model accuracy?",
  def: "No. A.R.C. governs behavior and context at runtime rather than modifying model weights or training methods."
},
{
  term: "How does A.R.C. decide when an agent should evolve or escalate?",
  def: "It evaluates tone, intent, domain cues, and policy fit. When a prompt falls outside scope, A.R.C. adjusts behavior or hands off the task without requiring retraining."
},
{
  term: "What if agents interpret a prompt differently?",
  def: "A.R.C. compares each agent’s confidence and constraint alignment, then blends or selects outputs to deliver a balanced and transparent response."
},
{
  term: "Can A.R.C. learn over time?",
  def: "It adapts its behavioral parameters through feedback, refining tone, escalation behavior, and constraint balance from real use."
},
{
  term: "How are agent responses synthesized?",
  def: "A controller agent reconciles outputs across domains through constraint-aware arbitration and tone alignment."
},
{
  term: "Will larger frontier models solve governance?",
  def: "No. Training improves factual accuracy, but not behavior. Runtime governance enables adaptive modulation and policy updates without retraining, ensuring consistency across contexts."
},
{
  term: "Can A.R.C. prevent harmful or off-policy outputs?",
  def: "A.R.C. enforces behavioral constraints in real time, reducing drift and policy violations through escalation, fallback, and constraint-aware synthesis."
},
{
  term: "How does the system assemble multiple agents?",
  def: "It derives a compact context signature from task semantics and tone, matching it to relevant domains and agents to determine whether to invoke a single role or a coordinated ensemble."
},
{
  term: "How does A.R.C. handle memory in regulated environments?",
  def: "It segments memory by type and applies constraint-aware rules for access, retention, and redaction. It enforces retention limits, filters sensitive content, and logs every access for review."
},
{
  term: "Can A.R.C. support multistep chaining of agent tasks?",
  def: "Yes. A.R.C. preserves behavioral and tonal continuity across chained agents, maintaining consistent context, policy alignment, and governance throughout."
},
{
  term: "How does A.R.C. differ from access governance?",
  def: "Access governance defines who can use a resource. A.R.C. governs how agents behave once access is granted, modulating tone, permissions, and escalation at runtime."
},
{
  term: "Does L.R.C. change the model’s weights?",
  def: "No. L.R.C. governs internal reasoning at runtime and shapes activation behavior without modifying or retraining the underlying model."
},
{
  term: "How does L.R.C. interact with A.R.C.?",
  def: "A.R.C. governs agent behavior at the surface. L.R.C. governs internal reasoning dynamics. Together they align how the system thinks with how it communicates and acts."
},
{
  term: "Can L.R.C. reduce hallucinations?",
  def: "It reduces risk by constraining internal reasoning patterns, limiting unsafe pathways, and guiding activation toward policy-aligned interpretations."
},
{
  term: "How does Adaptablox improve efficiency?",
  def: "By reducing unnecessary reasoning and limiting redundant agent or internal activation, Adaptablox minimizes compute waste and promotes efficient task routing."
},
{
  term: "Is L.R.C. compatible with interpretability tools?",
  def: "Yes. L.R.C. can incorporate insights from interpretability methods when available, but does not depend on any specific approach or tool."
},
{
  term: "Why govern internal reasoning at all? Isn’t output control enough?",
  def: "Output-only governance reacts to errors after they occur. L.R.C. addresses risk earlier by shaping internal reasoning before a response is generated."
},
{
  term: "Can L.R.C. work with any model?",
  def: "Yes. It is model-agnostic and compatible with proprietary, open, fine-tuned, or emerging architectures without requiring structural assumptions."
}
];

/* ---------- ELEMENTS ---------- */
const aboutBtn = document.getElementById('aboutBtn');
const termsBtn = document.getElementById('termsBtn');
const faqBtn = document.getElementById('faqBtn');
const flowsBtn = document.getElementById('flowsBtn');

const aboutEl = document.getElementById('about');
const termsEl = document.getElementById('terms');
const faqEl = document.getElementById('faq');
const asciiEl = document.getElementById('ascii');

const flowNav = document.getElementById('flowNav');
const prevFlow = document.getElementById('prevFlow');
const nextFlow = document.getElementById('nextFlow');

let activeFlipped = null;
let mode = "about";
let asciiIndex = 0;

/* ---------- CARD RENDERING ---------- */
function renderCards(targetEl, deck) {
targetEl.innerHTML = "";
deck.forEach(c => {
const div = document.createElement("div");
div.className = "card";
div.innerHTML = `
<div class="inner">
<div class="tilt">
<div class="face front"><h3>${c.term}</h3></div>
<div class="face back"><p>${c.def}</p></div>
</div>
</div>`;
div.addEventListener("click", () => {
if (activeFlipped && activeFlipped !== div) activeFlipped.classList.remove("flipped");
div.classList.toggle("flipped");
activeFlipped = div.classList.contains("flipped") ? div : null;
});
div.addEventListener("mousemove", e => {
  const tilt = div.querySelector(".tilt");
  const r = div.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  const rx = ((y - r.height / 2) / (r.height / 2)) * 10;
  const ry = ((x - r.width / 2) / (r.width / 2)) * -10;
  tilt.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) scale(1.05)`;

  const angle = Math.atan2(y - r.height / 2, x - r.width / 2) * (180 / Math.PI);

  div.querySelectorAll(".face").forEach(face => {
    face.style.setProperty("--lx", `${angle - 90}deg`);
  });
});

div.addEventListener("mouseleave", () => {
  const tilt = div.querySelector(".tilt");
  tilt.style.transform = "rotateX(0deg) rotateY(0deg) scale(1)";
  div.querySelectorAll(".face").forEach(face => {
    face.style.setProperty("--lx", "145deg"); // default angle
  });
});

targetEl.appendChild(div);
});
}

const asciiFlows=[
{
title:"Super-Agent Transparency Interface",
desc:"Enables a super-agent to delegate tasks to sub-agents while preserving full visibility into each sub-agent’s arc, constraint state, and reasoning trace.",
art:String.raw`
+----------------------------------------------+
|               SUPER-AGENT UI                 |
|   (Single entry point for user interaction)  |
+----------------------------------------------+
▼
+---------------------------------------------------+
|       TASK ROUTING / PROMPT INTERPRETATION        |
| - Parses prompt and identifies required domains   |
| - Applies arc classification for each sub-task    |
+---------------------------------------------------+
▼
+----------------------------------------------------------------+
|           BEHAVIORAL ARC DISPATCHER (Governed Delegation)      |
|   - Activates or assigns sub-agents with scoped arcs           |
|   - Applies constraint hierarchy & privilege controls          |
|   - Enforces domain-specific boundaries                        |
+----------------------------------------------------------------+
▼                     ▼                    ▼
+-------------------+  +----------------------+  +--------------------+
| Agent: Legal Bot  |  | Agent: Planner Bot   |  | Agent: Policy Bot  |
| Arc: Risk Review  |  | Arc: Deadline Push   |  | Arc: Consent Gate  |
+-------------------+  +----------------------+  +--------------------+
▼                        ▼                        ▼
+------------------------+ +-----------------------+ +------------------------+
|   Output + Metadata    | |   Output + Metadata   | |   Output + Metadata    |
| - Confidence indicator | | - Constraint labels   | | - Constraint outcome   |
| - Constraint record    | | - Tone vector         | | - Reasoning trace ref. |
+------------------------+ +-----------------------+ +------------------------+
\_____________________________________________/
▼
+-------------------------------------------------+
|         SUPER-AGENT OUTPUT ARBITRATOR           |
| - Harmonizes or prioritizes sub-agent results   |
| - Preserves origin context and constraint logic |
+-------------------------------------------------+
▼
+-------------------------------------------------+
|     FINAL OUTPUT TO USER (with trace metadata)  |
| - Includes contributing arcs and tone alignment |
+-------------------------------------------------+
▼
+------------------------------------------------------+
|      SUPER-AGENT AUDIT INTERFACE (transparency UI)   |
| - Trace chain of delegation                          |
| - Inspect constraint hierarchy per agent             |
| - Review reasoning flow through stored trace entries |
+------------------------------------------------------+<br><br>`
},
{
title:"Full Dual-Loop Governance Flow (A.R.C. → L.R.C.)",
desc:"Shows how Adaptablox governs both surface-level agent behavior and internal model reasoning. The outer loop (A.R.C.) modulates behavior, tone, memory, and delegation, while the inner loop (L.R.C.) guides latent reasoning and activation patterns. Together they form a unified governance layer that shapes how the system interprets inputs, reasons internally, and produces policy-aligned outputs.",
art:String.raw`
+----------------------------------------------+
|                USER INPUT                    |
|     (Natural language, task request, etc.)   |
+----------------------------------------------+
▼
+------------------------------------------------------+
|             OUTER LOOP: A.R.C. GOVERNANCE            |
|  - Interprets intent, tone, domain, and risk         |
|  - Selects or configures agents as needed            |
|  - Applies behavioral constraints and memory rules   |
+------------------------------------------------------+
▼
+------------------------------------------------------+
|             INNER LOOP: L.R.C. GOVERNANCE            |
|  - Oversees internal reasoning dynamics              |
|  - Guides activation patterns under policy           |
|  - Applies boundaries to internal representations    |
|  - Resolves conflicts in latent interpretations      |
+------------------------------------------------------+
▼
+------------------------------------------------------+
|                 MODEL REASONING LAYER                |
|   (Latent patterns, internal representations, etc.)  |
|     Governed at runtime but not modified as weights  |
+------------------------------------------------------+
▼
+------------------------------------------------------+
|              POLICY-ALIGNED SYSTEM OUTPUT            |
|   - Coherent reasoning                               |
|   - Consistent tone                                  |
|   - Traceable behavioral & internal governance       |
+------------------------------------------------------+<br><br>`
},
{
title:"Verified Agent Registry Reinstantiation Flow",
desc:"Determines whether to reactivate or initialize an agent by referencing its verified registry entry and evaluating policy-based continuity conditions. Uses constraint-aware memory handling to preserve compliant context when appropriate.",
art:String.raw`
+----------------------------------------------+
|         USER TASK / PROMPT RECEIVED          |
|   (Includes domain tags + context features)  |
+----------------------------------------------+
▼
+-------------------------------------------------+
|        TASK FINGERPRINT GENERATION MODULE       |
| - Derives a context signature from task details |
| - Identifies domain, intent, and tonal context  |
+-------------------------------------------------+
▼
+------------------------------------------------+
|       VERIFIED AGENT REGISTRY LOOKUP (VAR)     |
| - Compares signature against registered agents |
| - Evaluates suitability for reuse under policy |
+------------------------------------------------+
|                          |
Match Found in VAR           Match Not Found
▼                          ▼
+------------------------------------+      +---------------------------------+
|  RETRIEVE AGENT ARC + TONE PROFILE |      |  INSTANTIATE PROVISIONAL AGENT  |
| - Prepare for scoped reactivation  |      | - Assign minimal permissions    |
|                                    |      | - Apply baseline constraint set |
+------------------------------------+      +---------------------------------+
|                     
▼                     
+---------------------------------------+
|        MEMORY CONTINUITY CHECK        |
|   - Time-to-live and policy gates     |
+---------------------------------------+
▼                    ▼
+----------------------------+   +---------------------------+
| Memory Restoration Blocked |   |   Memory Restoration Ok   |
+----------------------------+   +---------------------------+
▼                    ▼
+--------------------------------+   +--------------------------------+
|  SUPPRESS MEMORY (STATELESS)   |   | RESTORE SCOPED MEMORY SEGMENTS |
| - Arc loads with fresh context |   | - Episodic + procedural data   |
+--------------------------------+   +--------------------------------+
▼                    ▼
+--------------------------------------------------+
|       ACTIVATE AGENT ARC IN CURRENT CONTEXT      |
| - Apply tone, constraint hierarchy, and scope    |
+--------------------------------------------------+
▼
+-------------------------------------------------------+
|                    AUDIT LOG ENTRY                    |
| - Records selection rationale                         |
| - Memory handling decision + reinstated arc ID        |
| - Link to prior session and constraint references     |
+-------------------------------------------------------+<br><br>`
},
{
title:"Task Signature and Multi-Agent Synthesis",
desc:"Identifies domain and intent from a user prompt to generate a context signature and determine which verified agents to engage. Specialized agents produce scoped outputs that the super-agent reconciles through tone alignment and constraint-governed arbitration to form a unified, policy-compliant response.",
art:String.raw`
+------------------------+
|       USER PROMPT      |
+------------------------+
▼
+---------------------------------------+
|        CONTEXT SIGNATURE MODULE       |
| - Derives context and intent cues     |
| - Classifies domain relevance         |
+---------------------------------------+
▼
+----------------------------------------------+
|     DOMAIN ARC MATCHING + CONSTRAINT CHECK   |
| - Evaluates agents by role and policy fit    |
| - Applies privilege and constraint controls  |
+----------------------------------------------+
▼
+---------------------------------------------+
|  OPTIONAL: VERIFIED AGENT REGISTRY (VAR)    |
| - Reuse compatible agent with scoped memory |
| - If match, restore prior arc context       |
+---------------------------------------------+
▼
+--------------------------------------------+
|   SHORTLISTED SPECIALIZED AGENTS SELECTED  |
| - Legal, PM, HR, etc.                      |
+--------------------------------------------+
▼
+------------+ +------------+ +------------+
| Agent A    | | Agent B    | | Agent C    |
| Arc: Legal | | Arc: PM    | | Arc: HR    |
| Tone: Caut.| | Tone: Firm | | Tone: Warm |
+------------+ +------------+ +------------+
|              |              |
Generate       Generate       Generate
Response       Response       Response
▼              ▼              ▼
+----------------+ +----------------+ +----------------+
| Response A     | | Response B     | | Response C     |
| Confidence tag | | Confidence tag | | Confidence tag |
| Constraint OK  | | Constraint OK  | | Constraint OK  |
| Tone profile A | | Tone profile B | | Tone profile C |
+----------------+ +----------------+ +----------------+
\_____________________________/
▼
+---------------------------------------------+
|      SUPER-AGENT RESPONSE ARBITRATOR        |
| - Reconciles tone and constraint alignment  |
| - Balances confidence and policy indicators |
+---------------------------------------------+
▼
+---------------------------------------------+
|           FINAL RESPONSE TO USER            |
| - Unified, context-aware, compliant output  |
+---------------------------------------------+

AUDIT TRAIL:<br>
• Task signature<br>
• Arc + tone Identifiers<br>
• Confidence and constraints outcomes<br><br>`
},
{
title:"Agent Ensemble Arbitration",
desc:"Coordinates collaborative decision-making across multiple domain agents. The arbitration process evaluates tone and policy alignment, applies constraint-aware prioritization, and produces a unified, context-appropriate outcome.",
art:String.raw`
+--------------------------------------------------+
|           MULTI-AGENT PROMPT RECEIVED            |
+--------------------------------------------------+
▼
+--------------------------------------------------------------+
|            ENSEMBLE AGENT SELECTION + ROLE CHECK             |
|   - Filters participating agents by domain relevance         |
|   - Loads each agent with its active arc and scoped context  |
+--------------------------------------------------------------+
▼
+-------------------+     +-------------------+     +-------------------+
|  Agent: Legal     |     | Agent: Product    |     | Agent: Compliance |
|  Arc: Risk Watch  |     | Arc: Launch Lead  |     | Arc: Policy Gate  |
+-------------------+     +-------------------+     +-------------------+
▼                         ▼                         ▼
+-------------------+     +-------------------+     +-------------------+
| Proposes Output   |     | Proposes Output   |     | Proposes Output   |
| - Confidence tag  |     | - Confidence tag  |     | - Confidence tag  |
| - Constraint data |     | - Constraint data |     | - Constraint data |
+-------------------+     +-------------------+     +-------------------+
\_________________/      \________________/
 ▼                       ▼
+----------------------------------------------+
|      ARC ARBITRATOR (Resolution Engine)      |
| - Evaluates tone and policy consistency      |
| - Applies constraint-informed prioritization |
| - Ensures domain and role alignment          |
+----------------------------------------------+
▼
+----------------------------------------------+
|         CONSENSUS / ESCALATION LOGIC         |
| - Determines unified response or escalation  |
| - May defer to fallback or oversight agent   |
+----------------------------------------------+
▼
+-------------------------------------------------+
|          SYNTHESIZED OR SELECTED OUTPUT         |
| - Annotated with contributing arcs and agents   |
| - Reflects governed alignment across ensemble   |
+-------------------------------------------------+
▼
+-------------------------------------------------+
|         AUDIT TRAIL FOR ENSEMBLE RESPONSE       |
| - Reasoning trace (SCoT), arc participation     |
| - Alignment rationale and resolution summary    |
+-------------------------------------------------+<br><br>`
},
{
title:"Fallback, Micro-Arc Injection, and Escalation Recovery",
desc:"Addresses ambiguous or high-risk prompts through layered governance reflexes—constraint evaluation, fallback activation, and temporary micro-arc insertion. When no local arc can respond within policy, the system delegates to a verified agent under scoped memory and produces a transparent, auditable outcome annotated with reasoning context.",
art:String.raw`
+-------------------------+
|       USER PROMPT       |
+-------------------------+
▼
+---------------------------------------+
|       CONTEXT SIGNATURE MODULE        |
| - Identifies domain and intent cues   |
+---------------------------------------+
▼
+----------------------------------------------+
|     DOMAIN ARC REVIEW + CONSTRAINT CHECK     |
| - No clear domain fit or policy alignment    |
+----------------------------------------------+
▼
+----------------------------------------------+
|    REFLEXIVE CONSTRAINT EVALUATION LAYER     |
| - Detects potential policy or tone risk      |
| - Low assurance → initiate fallback arc      |
| - Constraint mismatch → apply micro-arc      |
+----------------------------------------------+
 |                            |
Fallback Initiated           Micro-Arc Applied
 ▼                            ▼
+----------------------------+            +-----------------------------+
| Engage Fallback Arc        |            | Insert Temporary Constraint |
| - Tone adjusted            |            | - Restrict specific action  |
| - Scope limited            |            | - Time-bounded control      |
+----------------------------+            +-----------------------------+
\________________________________________/
▼
+-----------------------------------------------+
| ESCALATION CONTROLLER (If no arc is suitable) |
| - Consult verified registry for trusted agent |
| - Reuse scoped memory when permitted          |
+-----------------------------------------------+
▼
+-----------------------------+
| Delegated Agent D           |
| Arc: Specialized Domain     |
| Memory: Scoped              |
| Tone: Context-sensitive     |
+-----------------------------+
▼
+----------------------------+
| Response aligned with task |
| Assurance: High            |
| Context: Relevant segment  |
+----------------------------+
▼
+---------------------------------------------+
|   SUPER-AGENT SYNTHESIS + MODULATION LOGIC  |
| - Harmonizes tone with current context      |
| - Annotates fallback / micro-arc events     |
+---------------------------------------------+
▼
+------------------------------------------+
|  FINAL OUTPUT: Context-Aware + Auditable |
| - Transparent escalation record          |
+------------------------------------------+

AUDIT TRAIL:<br>
• Constraint evaluation trigger<br>
• Micro-arc event (duration, scope)<br>
• Fallback rationale and arc ID<br>
• Escalation record to external domain<br>
• Memory-access decision and justification<br><br>`
},
{
title:"Just-In-Time (JIT) Micro-Arc Injection",
desc:"Temporarily introduces focused constraints into an active behavioral arc to correct policy drift or prevent non-compliant actions in real time—without retraining or full re-initialization.",
art:String.raw`
+----------------------------------------------+
|            ACTIVE BEHAVIORAL ARC             |
|   (Arc ID, domain, tone, privilege scope)    |
+----------------------------------------------+
▼
+----------------------------------------------+
|     CONTEXT MONITORING AND TRIGGER REVIEW    |
|  - Identifies potential policy deviations    |
|  - Evaluates inputs against escalation rules |
+----------------------------------------------+
▼
+----------------------------------------------+
|      MICRO-ARC INJECTION CONTROLLER          |
| - Establishes a temporary constraint arc     |
| - Defines active duration and governing role |
| - Prioritizes over existing constraints      |
+----------------------------------------------+
▼
+-------------------------------------------------------+
|       CONSTRAINT STACK UPDATE (Injection Event)       |
|  - Places micro-arc at top of hierarchy               |
|  - Suspends affected permissions and tone parameters  |
+-------------------------------------------------------+
▼
+-----------------------------------------------------+
|         MODULATED OUTPUT GENERATION PATH            |
| - Continues operation under temporary constraint    |
| - May defer action, soften tone, or request review  |
+-----------------------------------------------------+
▼
+---------------------------------------------+
|             FINAL OUTPUT ISSUED             |
+---------------------------------------------+
▼
+-------------------------------------------------------+
|                 AUDIT RECORD CREATED                  |
| - Micro-arc event details (trigger, duration, scope)  |
| - Constraint-stack status before and after injection  |
+-------------------------------------------------------+<br><br>`
},
{
title:"Constraint-Governed Memory",
desc:"Manages how an agent accesses, retains, and modifies information through constraint-linked permissions associated with its active arc—ensuring compliant retention, adaptive decay, and transparent auditability.",
art:String.raw`
+---------------------------------------------+
|           AGENT MEMORY FRAMEWORK            |
+---------------------------------------------+
▼
+----------------------------------------------------------------------------+
|                   SEGMENTED MEMORY FRAMEWORK (By Type)                     |
| +---------------------+  +---------------------+  +----------------------+ |
| |   Short-Term (STM)  |  |  Long-Term Semantic |  |      Procedural      | |
| | - Session context   |  | - Facts, concepts   |  | - Operational habits | |
| | - Live tools I/O    |  | - Domain knowledge  |  |                      | |
| +---------------------+  +---------------------+  +----------------------+ |
+----------------------------------------------------------------------------+
▼
+---------------------------------------------+
|         CONSTRAINT-AWARE CONTROLLER         |
| - Evaluates arc role and domain privileges  |
| - Applies layered constraint permissions    |
| - Restricts or masks disallowed segments    |
+---------------------------------------------+
▼
+----------------------------------------------------------+
|           MEMORY CONSOLIDATION AND ABSTRACTION           |
| - Summarizes infrequent or expired content               |
| - Filters sensitive data under active constraints        |
| - Captures rationale and provenance for audit reference  |
+----------------------------------------------------------+
▼
+--------------------------------------------+
|     RETENTION & EXPIRATION GOVERNANCE     |
| - Enforces retention time policies        |
| - Allows temporary constraint extensions  |
| - Flags records for review or removal     |
+--------------------------------------------+
▼
+----------------------------------------------------+
|              AUDIT AND TRACE GENERATION            |
| - Logs all access and modification events          |
| - Associates entries with arc and constraint data  |
| - Enables oversight and compliance review          |
+----------------------------------------------------+<br><br>`
},
{
title:"Tone Modulation",
desc:"Continuously adapts an agent’s communicative stance—formality, empathy, urgency, and hedging—based on context, arc configuration, and situational cues to maintain role-appropriate expression and policy alignment.",
art:String.raw`
+-----------------------------------+
|       TONE MODULATION LAYER       |
+-----------------------------------+
▼
+---------------------------------------------------------------+
|                    BASELINE TONE PROFILE                      |
|           (Defined per Arc Role and Domain Context)           |
|   - Established during arc initialization                     |
|   - Includes dimensions such as empathy, directness, urgency  |
+---------------------------------------------------------------+
▼
+-----------------------------------------------------------------------+
|                 RUNTIME CONTEXT INPUTS FOR MODULATION                 |
| +--------------------------------+ +--------------------------------+ |
| |  Assurance and Context Inputs  | |   User Preference Indicators   | |
| | - Output certainty cues        | | - Desired tone, politeness     | |
| | - Constraint alignment status  | | - Prior interaction style      | |
| +--------------------------------+ +--------------------------------+ |
| +--------------------------------+ +--------------------------------+ |
| |   Task Sensitivity Markers     | |   Environmental Context Flags  | |
| | - Compliance, emotion level    | | - Urgency, domain mix, setting | |
| +--------------------------------+ +--------------------------------+ |
+-----------------------------------------------------------------------+
▼
+-------------------------------------------------+
|    MODULATION CONTROLLER (Tone Adjustment)      |
| - Integrates baseline tone with active inputs   |
| - Updates tone profile according to policy      |
| - Validates consistency with arc role           |
+-------------------------------------------------+
▼
+---------------------------------------------------+
|    ROLE ALIGNMENT GUARD (Boundary Enforcement)    |
| - Detects tone deviations from role intent        |
| - Initiates fallback or escalation when required  |
+---------------------------------------------------+
▼
+---------------------------------------------+
|         MODULATED OUTPUT GENERATED          |
| - Language adapted dynamically              |
| - Includes confidence hedging or softening  |
+---------------------------------------------+
▼
+----------------------------------------------------+
|         AUDIT ENTRY FOR MODULATION EVENT           |
| - Captures tone profile change and context inputs  |
| - Records alignment validation outcome             |
+----------------------------------------------------+<br><br>`
},
];

function renderAscii() {
asciiEl.innerHTML = "";
const f = asciiFlows[asciiIndex % asciiFlows.length];
asciiEl.innerHTML = `
<div class="ascii-slide">
<div class="ascii-title">${f.title}</div>
<div class="ascii-desc">${f.desc}</div>
<pre class="ascii-pre">${f.art}</pre>
</div>`;
}

/* ---------- VIEW SWITCHING ---------- */
function setMode(m, fromHash = false) {
  const buttons = [aboutBtn, termsBtn, faqBtn, flowsBtn];
  const sections = [aboutEl, termsEl, faqEl, asciiEl];

  // Clear all active states
  buttons.forEach(b => b.classList.remove("active"));
  sections.forEach(s => {
    s.classList.remove("active");
    s.style.display = "none"; // hide all
  });

  // Determine target and render content
  let target = null;
  if (m === "about") {
    target = aboutEl;
    aboutBtn.classList.add("active");
  } else if (m === "terms") {
    renderCards(termsEl, termsDeck);
    target = termsEl;
    termsBtn.classList.add("active");
  } else if (m === "faq") {
    renderCards(faqEl, faqDeck);
    target = faqEl;
    faqBtn.classList.add("active");
  } else if (m === "flows") {
    renderAscii();
    target = asciiEl;
    flowsBtn.classList.add("active");
  } else {
    // fallback
    target = aboutEl;
    aboutBtn.classList.add("active");
  }

  // Toggle flow nav visibility
  flowNav.style.display = (m === "flows") ? "flex" : "none";

  // Reset scroll
  window.scrollTo({ top: 0, behavior: "auto" });

  // Show and animate the selected section
  if (target) {
    // Ensure correct display type
    if (target.classList.contains("card-container")) {
      target.style.display = "grid";
    } else {
      target.style.display = "block";
    }

    requestAnimationFrame(() => target.classList.add("active"));
  }

  // Update the URL hash unless triggered by hash navigation
  if (!fromHash) {
    history.pushState(null, "", `#${m}`);
  }
}

/* ---------- HASH-BASED NAVIGATION ---------- */
window.addEventListener("DOMContentLoaded", () => {
  const hash = window.location.hash.replace("#", "");
  if (["about", "terms", "faq", "flows"].includes(hash)) {
    setMode(hash, true);
  } else {
    setMode("about", true);
  }
});

window.addEventListener("popstate", () => {
  const hash = window.location.hash.replace("#", "");
  setMode(hash || "about", true);
});

/* ---------- NAVIGATION ---------- */
aboutBtn.onclick = () => setMode("about");
termsBtn.onclick = () => setMode("terms");
faqBtn.onclick = () => setMode("faq");
flowsBtn.onclick = () => setMode("flows");
prevFlow.onclick = () => {
asciiIndex = (asciiIndex - 1 + asciiFlows.length) % asciiFlows.length;
renderAscii();
window.scrollTo({ top: 0, behavior: "smooth" }); // scroll page to top
};

nextFlow.onclick = () => {
asciiIndex = (asciiIndex + 1) % asciiFlows.length;
renderAscii();
window.scrollTo({ top: 0, behavior: "smooth" }); // scroll page to top
};
/* ---------- DEFAULT VIEW ---------- */
</script>
<footer class="site-footer">
<p>© 2025 Bart Yeary. All rights reserved. A.R.C.™ — Patent Pending.</p>
</footer>
</body>
</html>